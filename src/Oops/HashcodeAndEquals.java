package Oops;

// Must Read:- [VVVVVVI]
// https://www.infoworld.com/article/3305792/comparing-java-objects-with-equals-and-hashcode.html
// Anuj bhaiya youTube video:- https://www.youtube.com/watch?v=nWWuk_DeYVo&t=362s

import java.util.HashSet;

class Employee {

    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this)
            return true;
        if (!(obj instanceof Employee))
            return false;
        Employee employee = (Employee) obj;
        return employee.getAge() == this.getAge()
                && employee.getName() == this.getName();
    }

    // commented
      @Override
        public int hashCode() {
            int result=17;
            result=31*result+age;
            result=31*result+(name!=null ? name.hashCode():0);
            return result;
        }

}


public class HashcodeAndEquals {
    public static void main(String[] args) {
        Employee employee = new Employee("rajeev", 24);
        Employee employee1 = new Employee("rajeev", 25);
        Employee employee2 = new Employee("rajeev", 24);

        HashSet<Employee> employees = new HashSet<Employee>();
        employees.add(employee);
        System.out.println(employees.contains(employee2));
        System.out.println("employee.hashCode():  " + employee.hashCode()
                + "  employee2.hashCode():" + employee2.hashCode());
    }
}

/*
Q) what is the use of Hascode() in java?
Ans)

hashCode() is used for bucketing in Hash implementations like HashMap, HashTable, HashSet, etc.
The value received from hashCode() is used as the bucket number for storing elements of the set/map.
 This bucket number is the address of the element inside the set/map.
When you do contains() it will take the hash code of the element,
 then look for the bucket where hash code points to.
  If more than 1 element is found in the same bucket (multiple objects can have the same hash code),
   then it uses the equals() method to evaluate if the objects are equal,
   and then decide if contains() is true or false, or decide if element could be added in the set or not.

=> hashCode() is a function that takes an object and outputs a
numeric value[unique code which is generated by the JVM for every object creation].
 The hashcode for an object is always the same if the object doesn't change.
 */


//    Collections such as HashMap and HashSet use a hashcode value of an object to determine how it should be stored inside a collection,
//    and the hashcode is used again in order to locate the object in its collection.
//
//        Hashing retrieval is a two-step process:
//
//        Find the right bucket (using hashCode())
//        Search the bucket for the right element (using equals() )
//
//        Here is a small example on why we should overrride equals() and hashcode().
/*

 MUST READ:- [https://stackoverflow.com/a/66846607] // very detail answer
 Key Points:-

 1) Default implementation of hashCode() which is inherited from Object considers all objects in memory unique!
 means, By default hashCode() method returns a different result for each different instance
 2) Keep in mind however, if we don't provide our custom version of .equals() (aka override) in our class then
    the predefined .equals() from Object class and == operator will behave exactly the same.
    Default equals() method which is inherited from Object will check whether both compared
    instances are the same in memory!
 3) How operator == works.
It checks if 2 references that we compare point to the same instance in memory.
Operator == will resolve to true only if those 2 references represent the same instance in memory.
 */


/* .EQUALS() vs ==

1) .equals(...) will only compare what it is written to compare, no more, no less.
2) If a class does not override the equals method, then it defaults to the equals(Object o) method
 of the closest parent class that has overridden this method.
3) If no parent classes have provided an override, then it defaults to the method from the ultimate parent
 class, Object, and so you're left with the Object#equals(Object o) method. Per the Object API this is the
  same as ==; that is, it returns true if and only if both variables refer to the same object, if their
  references are one and the same. Thus you will be testing for object equality and not functional equality.
4) We can use == operators for reference comparison (address comparison) and .equals() method for content
 comparison. In simple words, == checks if both objects point to the same memory location whereas .equals()
  evaluates to the comparison of values in the objects.

        String s1 = "HELLO"; // Stores in String constant pool
        String s2 = "HELLO"; // Stores in String constant pool
        String s3 =  new String("HELLO"); // Stores in heap i.e new keyword

        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // false
        System.out.println(s1.equals(s2)); // true
        System.out.println(s1.equals(s3)); // true

    => Both s1 and s2 refer to same objects.
    => When we use the == operator for s1 and s2 comparison, the result is true as both have the same addresses
     in the string constant pool.
    => Using equals, the result is true because itâ€™s only comparing the values given in s1 and s2.


*/